var IocError = require( '../genericHelpers/IocError.js' )(),
	log = require( '../log/log.js' )( 'resolver' ),
	errRerouter = require( '../genericHelpers/errRerouter.js' )(),
	resolvedComponent = require( '../containerHelpers/resolvedComponent.js' )(),
	wrapper = require( '../wrapping/wrapper.js' )(),
	timer = require( '../genericHelpers/timer.js' )( 2000 ),
	wrapper = require( '../wrapping/wrapper.js' )(),
	injectableComponent = require( './injectableComponent.js' )();
module.exports = function() {
	var pub = {};
	pub.resolveInjectableComponent = function( parentName, component, resolvedNonReservedDependencies, callback ) {
		var pub = {},
			setupFn,
			asyncCallback = [ function( instance ) {
				setImmediate( callback, undefined, component.dependencies.hasPub ? pub : instance );
			}, function() {} ];
		var instance = component.fn.apply( undefined, component.dependencies.parameters.map( function( dependency ) {
			if( !dependency.isReserved )
				return resolvedNonReservedDependencies[ dependency.name ];
			else if( dependency.isCallback )
				return asyncCallback.shift();
			else if( dependency.isParentName )
				return parentName;
			else if( dependency.isPub )
				return pub;
			else if( dependency.isSetup ) {
				return function( setup ) {
					setupFn = setup;
				};
			}
		} ) );
		if( setupFn )
			setupFn();
		asyncCallback.shift()( instance );
	};
	var resolveDependencies = function( store, name, nonReserved, callback ) {
		( function recursive( resolved ) {
			if( !nonReserved.length )
				callback( undefined, resolved );
			else {
				var dependencyName = nonReserved.pop();
				pub.resolve( store, dependencyName, name, errRerouter( callback, function( instance ) {
					resolved[Â dependencyName ] = instance;
					recursive( resolved );
				} ) );
			}
		} )( {} );
	};
	pub.registerGlobalWrapper = function( name, wrapperResolveFn ) {
		wrapper.registerWrapper( name, wrapperResolveFn );
	};
	pub.inject = function( store, fn, parentName, callback ) {
		var component = injectableComponent.get( fn );
		resolveDependencies( store, 'anonymousFunction', component.dependencies.nonReserved, function( err, resolvedNonReservedDependencies ) {
			if( err )
				log.fatal( 'Cannot resolve dependencies for anonymous function', err );
			else
				pub.resolveInjectableComponent( parentName, component, resolvedNonReservedDependencies, function( err, instance ) {
					if( callback )
						callback();
				} );
		} );
	};
	pub.resolve = function( store, name, parentName, callback ) {
		if( !store.isResolvable( name ) ) {
			setImmediate( callback, new IocError( 'Component unresolvable', store.getResolvingProblems( name ) ) );
		}
		else if( store.isResolved( name ) ) {
			store.addUsage( name, parentName );
			wrapper.wrap( parentName, name, store.getResolved( name ).instance, function( err, wrappedInstance ) {
				callback( undefined, wrappedInstance );
			} );
		}
		else {
			log.trace( 'Resolving', name );
			timer.startTimer( name );
			var component = store.getInjectable( name );
			resolveDependencies( store, name, component.dependencies.nonReserved, errRerouter( callback, function( resolvedNonReservedDependencies ) {
				pub.resolveInjectableComponent( parentName, component, resolvedNonReservedDependencies, errRerouter( callback, function( instance ) {
					timer.stopTimer();
					if( component.isTransient )
						log.debug( 'Resolved transient', name );
					else
						store.setResolved( name, resolvedComponent.get( instance ) );
					store.addUsage( name, parentName );
					wrapper.wrap( parentName, name, instance, function( err, wrappedInstance ) {
						callback( undefined, wrappedInstance );
					} );
				} ) );
			} ) );
		}
	};
	return pub;
};