var fs = require( 'fs' ),
	path = require( 'path' ),
	IocError = require( '../genericHelpers/IocError.js' )(),
	log = require( '../log/log.js' )( 'files' ),
	anoymousParentResolver = require( '../genericHelpers/anonymousParentResolver.js' )();
module.exports = function() {
	var pub = {};
	var notifyLineCount = function( name, fileContent ) {
		var lineCount = fileContent.split( '\n' ).length;
		if( lineCount > 300 )
			log.error( 'Component consists of more than 300 lines (' + lineCount + ')', name );
		else if( lineCount > 200 )
			log.warning( 'Component consists of more than 200 lines (' + lineCount + ')', name );
		else if( lineCount > 100 )
			log.info( 'Component consists of more than 100 lines (' + lineCount + ')', name );
	};
	var getModuleName = function( absolutePath ) {
		return path.basename( absolutePath, '.js' );
	};
	var getNormalizedPath = function( relativePath, stepsBack ) {
		return relativePath.indexOf( '/' ) === 0 ?
			relativePath :
			path.normalize( [ anoymousParentResolver.resolvePath( stepsBack ), relativePath ].join( '/' ) );
	};
	var hasValidFileEnding = function( absolutePath ) {
		return [ '.js' ].indexOf( path.extname( absolutePath ) ) >= 0;
	};
	var shouldIgnore = function( fileContent ) {
		return fileContent.replace( /\n|\r/g, '' ).search( /\/\*(.*ioc:ignore.*?)\*\// ) >= 0;
	};
	var isAlreadyResolved = function( fileContent ) {
		return fileContent.replace( /\n|\r/g, '' ).search( /\/\*(.*ioc:noresolve.*?)\*\// ) >= 0;
	};
	var scanPath = function( absolutePath ) {
		var result = { injectables: {}, resolved: {} };
		var addToResult = function( recursivePath ) {
			var name = getModuleName( recursivePath ),
				fileContent = fs.readFileSync( recursivePath, 'utf-8' );
			notifyLineCount( name, fileContent );
			if( !shouldIgnore( fileContent ) ) {
				if( !result[ isAlreadyResolved( fileContent ) ? 'resolved' : 'injectables' ][ name ] )
					result[ isAlreadyResolved( fileContent ) ? 'resolved' : 'injectables' ][ name ] = require( recursivePath );
				else
					throw new IocError( 'Component with same name exists in path', name );
			}
		};
		( function recursive( recursivePath ) {
			if( fs.existsSync( recursivePath ) ) {
				if( fs.lstatSync( recursivePath ).isDirectory() )
					fs.readdirSync( recursivePath ).forEach( function( filename ) {
						recursive( path.resolve( recursivePath, filename ) );
					} );
				else if( hasValidFileEnding( recursivePath ) )
					addToResult( recursivePath );
			}
			else
				throw( new Error( 'Could not find file: ' + recursivePath ) );
		} )( absolutePath );
		return result;
	};
	pub.getModulesInPath = function( relativePath, stepsBack ) {
		return scanPath( getNormalizedPath( relativePath, ( stepsBack || 0 ) + 1 ) );
	};
	return pub;
};