# simple-ioc
============

TODO: Description

## Installation
```
npm install simple-ioc
```

## Basic concept

TODO: Description

## ioc
======

### Methods
-----------

### getContainer()
See section [container](#log) for more information about containers.

#### Arguments
None.

#### Returns
A new container.

#### Remarks
After the container is created, it has itself and the ioc registered.

#### Example
```javascript
require( 'simple-ioc' ).getContainer()
```

***

### getSettings()
Gets the settings the ioc uses. This method is used internally by the container.

#### Arguments
None.

#### Returns
The registered settings

#### Remarks
The default settings for the ioc are
```
{
	log: {
		level: 0,
		includeEnvironemtVariables: { env: 'NODE_ENV' },
		output: 'devNull'
	}
}
```

#### Example
```javascript
require( 'simple-ioc' ).setSettings( {
	key: 'value'
} ).getSettings();
// will return { key: 'value' } (if no settings was blank before)
```

***

### setSettings( settings1, settings2, settings3... )
Sets the settings the ioc will read, currently the only root-property is log, see section [log](#log) for more information about the built in log.

#### Arguments
Variable amount of objects with settings, the settings will be merged with the existing settings.

#### Returns
The ioc

#### Remarks
The ioc has 4 built-in output-writers, these are
* consoleJson - More or less console.log( JSON.stringify( logObject ) )
* consoleReadable - Logs in a readable format, with some coloring of level
* devNull - writes nothing
* memoryJson - writes to memory, which is searchable afterwards. This should never be used in production, only in tests.

The default settings are:
```
{
	log: {
		level: 0,
		includeEnvironemtVariables: { env: 'NODE_ENV' },
		output: 'devNull'
	}
}
```

#### Example
```javascript
require( 'simple-ioc' ).setSettings( {
	log: {
		level: 3
	},
	{
		includeEnvironemtVariables: { env: 'ENVIRONMENT_NAME' }
		output: 'consoleReadable'
	}
}, {
	
} ).getSettings();
/*
will return
	{
		level: 3,
		includeEnvironemtVariables: { env: 'ENVIRONMENT_NAME' },
		output: 'consoleReadable'
	}
*/
```

***

### useLogWriter( resolvedWriter )
The internal logger can also use a external output writer, it must implement the following functions:
* output( logObject ) - called on every log that is on a level that should be logged.
* getEntries( component ) - can be implemented, but should not be used in production
* reset() - if getEntries is implemented, this one should too.

#### Arguments
* resolvedWriter - an object that implements at least output( logObject )

#### Returns
the ioc.

#### Remarks
None.

#### Example
```javascript
require( 'simple-ioc' ).useLogWriter( {
	output: function( logObject ) {
		console.log( logObject.level );
	}
} );
// Will only ouptut the level of the log (numeric) to the console.
```

***

## log
======

The ioc has a built in logger that can be used externaly as well. The logger builds a logObject that looks like this:
```javascript
{
	level: level,
	message: message,
	data: data,
	component: parentName,
	...environment variables specified in settings
}
```

In the log-settings you can specify envronment values that you would like to include in the log-objects
```javascript
includeEnvironemtVariables: { enviro: 'ENV_NAME' }
// Would include ENV_NAME as "enviro"
```

By calling ``` registerIocLog( name ) ``` on the container the logger will be registered in the containeras the name specified. 

---

## container
============
Containers are the central part of the ioc, it stores and resolves components.

Note: All functions on the container returns the container itself.

### Methods
-----------

### registerResolved( name, instance )
Registers a already resolved component to the container, e.g. external external componens like "express".

#### Arguments
* name - the identifying name of the component
* instance - the resolved instance
OR
* name - An object with key/value pairs reprecenting names/instances

#### Returns
The container

#### Remarks
None.

#### Example
```javascript
var container = require( 'simple-ioc' ).getContainer()
	.registerResolved( http: require( 'http' ) )
	.registerResolved( {
		express: require( 'express' ),
		request: require( 'request' )
	} );
	// Registers http, express and request as http, express and request
```

***

### registerInjectable( name, fn )
Registers an injectable component in the container, this method should normally be used when registering internal libraries which can use their own containers.

#### Arguments
* name - the identifying name of the component
* fn - the injectable function

OR

* name - An object with key/value pairs reprecenting names/instances

#### Returns
The container.

#### Remarks
Injectable functions has some reserved parameternames used by the ioc, these cannot be registered or used as normal dependencies. The reserved are (all are optional):
* pub - can be used to set the values properties of the component. If it is not used the ioc will use whatever the component returns or if it has an asyncronous callback, whatever is used as the first argument.
* setup - can be used if the component needs to be setup (will be used in future versions)
* parentName - If used, the component will be transient instead of singleton. The vaule will be the name of the component that was depending on the component.
* callback - If a component has this dependency the ioc will wait until callback is called before continuing resolving more components. 

#### Example
```javascript
var container = require( 'simple-ioc' ).getContainer()
	.registerInjectable( 'myComponent', function( pub, callback ) {
		pub.func1 = function( params ) {
			return whatEver;
		};
		doSomething( function() {
			callback();
		} )
	} ) // Registers a singleton component that has an async setup and a function func1 as myComponent
	.registerInjectable( {
		anotherComponent: function( setup, pub, callback ) {
			setup( function() {
				someSetup( function() {
					pub.xxx = function() {
						return amazingStuff;
					};
					callback();
				} );
			} );
			// Registers a singleton component that has a setup that also is async. The result is a
			// component registered as anotherComponent with a function xxx.
		},
		yetAnother: function( parentName ) {
			return {
				func3: function() {
					return parentName;
				}
			};
			// Registeres a transient component as yetAnother with a function func3. Everytime yetAnother
			// is injected the registered function will be called, creating a new enclosed scope.
		}
	} );
```


***

### registerGlobalWrappersFromSettings( settingsKey )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### autoRegisterPath( relativePath )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### resolve( name, callback )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### registerIocSettings( name )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### registerIocLog( name )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### resolveAllAndInject( fn )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### inject( fn, callback )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### registerResolvedIfSetting ( settingKey, name, instance )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### registerInjectableIfSetting( settingKey, name, fn )

#### Arguments

#### Returns

#### Remarks

#### Example

***

### autoRegisterPathInSetting( settingKey )

#### Arguments

#### Returns

#### Remarks

#### Example

***
